package classes;

/**
 * класс предлагающий автодополнение по двум первым введенным буквам.
 * 
 * @author Iaroslav_Grytsaienko
 *
 */
public class PrefixMatcher {

	private Trie trie;

	/**
	 * Constructor
	 */
	public PrefixMatcher() {
		trie = new RWayTrie();
	}

	/**
	 * ‘ормирует in-memory словарь слов. ћетод принимает слово, строку, массив
	 * слов/строк. ≈сли приходит строка, то она разбиваетс€ на слова по
	 * пробелам. ¬ словарь должны добавл€тьс€ слова длиннее 2х символов.
	 * ѕредполагаетс€ что знаки пунктуации отсутствуют.
	 * 
	 * @param strings
	 * @return
	 */
	public int add(String... strings) {

		for (String string : strings) {
			String[] splitedBySpace = string.split(" ");
			for (String strSplitterBySpace : splitedBySpace) {
				String[] trimmedStringsAndSplitterByTab = strSplitterBySpace.trim().split("\\t");
				for (String str : trimmedStringsAndSplitterByTab) {
					addString(str);
				System.out.println(trie.size());
				}
			}
		}
		return trie.size();
	}

	/**
	 * Inserts words started only with letter with at least 3 symbols length.
	 * Convert all letters of the words to lower-case letters.
	 * 
	 * @param str
	 *            input word
	 */
	private void addString(String str) {
		if (str.charAt(0) > 64 && str.length() > 2) {
			if (trie == null) {
				trie = new RWayTrie();
			}
			trie.add(new Tuple(str.toLowerCase()));
		}
	}

	/**
	 * есть ли слово в словаре
	 * 
	 * @param word
	 * @return
	 */
	public boolean contains(String word) {
		return trie.contains(word);
	}

	/**
	 * удал€ет слово из словар€
	 * 
	 * @param word
	 * @return
	 */
	public boolean delete(String word) {
		return trie.delete(word);
	}

	/**
	 * к-во слов в словаре
	 * 
	 * @return
	 */
	public int size() {
		return trie.size();
	}

	/**
	 * если введенный pref длиннее или равен 2м символам, то возвращает набор
	 * слов k разных длин начина€ с минимальной, и начинающихс€ с данного
	 * префикса pref. ѕример, даны слова следующей длины и pref='abc': abc 3
	 * abcd 4 abce 4 abcde 5 abcdef 6 - при k=1 возвращаютс€ 'abc' - при k=2
	 * возвращаютс€ 'abc', 'abcd', 'abce' - при k=3 возвращаютс€ 'abc', 'abcd',
	 * 'abce', 'abcde' - при k=4 возвращаютс€ 'abc', 'abcd', 'abce', 'abcde',
	 * 'abcdef'
	 * 
	 * @param pref
	 * @param k
	 * @return
	 */

	public Iterable<String> wordsWithPrefix(String pref, int k) {
		return trie.wordsWithPrefix(pref);
	}

	/**
	 * если введенный pref длиннее или равен 2м символам, то возвращает набор
	 * слов k=3 разных длин начина€ с минимальной, и начинающихс€ с данного
	 * префикса pref.
	 * 
	 * @param pref
	 * @return
	 */
	//
	public Iterable<String> wordsWithPrefix(String pref) {
		return trie.wordsWithPrefix(pref);
	}
}
